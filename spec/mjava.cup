//todo a[0]++ not working because u are reloading things
package rs.ac.bg.etf.pp1.sm130075d;
import java.io.File;
import java.io.FileOutputStream;
import rs.etf.pp1.mj.runtime.*;
import java.util.stream.Collectors;
import java.util.*;
import java_cup.runtime.*;
import rs.etf.pp1.symboltable.structure.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.*;

init with {:
  Tab.init();
  boolType = new Struct(Struct.Bool);
  boolObj = new Obj(Obj.Type, "bool", boolType);

  Tab.currentScope().addToLocals(new Obj(Obj.Type, "bool", boolType));
:}

action code {:
    Struct varTypeHelper;
    int opCode = -1;
    boolean hasOperand = false;
    Obj helperObj;
    Obj helperObj2;
    Stack<Integer> startPC = new Stack<Integer>();
    Stack<Integer> endPC = new Stack<Integer>();
    int backAddr;
    Stack<Integer> breakJumpAddr = new Stack<Integer>();
    Stack<Integer> breakJumpNum = new Stack<Integer>();
    Obj methodObjHelper;
    Obj conHelper;
    Stack<Integer> rArgCounters = new Stack<Integer>();
    Stack<Obj> methodCalls = new Stack<Obj>();
    Stack<Integer> falseJumpAddr = new Stack<Integer>();
    Stack<Integer> trueJumpAddr = new Stack<Integer>();
    Stack<Integer> condEndJump = new Stack<Integer>();
    Stack<Integer> forEndJump = new Stack<Integer>();
    Stack<Integer> numOfFacts = new Stack<Integer>();
    Stack<Integer> numOfTerms = new Stack<Integer>();
    Stack<Obj> objHelpers = new Stack<Obj>();
    boolean isComplexObj = false;
    Stack<Integer> addresses = new Stack<Integer>();
    Stack<VirtualTable> vts = new Stack<VirtualTable>();
    int offset;
    Obj arrayHelper = null;
    Obj methodObj;
    Obj classObj;
    Obj objHelper;
    Obj desHelper;
    Obj thisHelper;
    boolean classCall = false;
    Struct extendsType;
    Struct classT;
    int dataSize = 0;
    int argCount = 0;
    int rArgCount = 0;
    int globalVar = 0;
    int globalFunc = 0;
    int localVar = 0;
    int globalConst = 0;
    int globalArrays = 0;
    int classDef = 0;
    int classMethodDef = 0;
    int statementBlock = 0;
    int mainFuncCalls = 0;
    int formalArguments = 0;
    int classFields;
    int formParsCnt;
    boolean isArray;
    int arrays = 0, vars = 0, consts = 0, methods = 0;;
    boolean insideClass = false;
    boolean insideMethod = false;
    boolean global = true;
    boolean insideMain = false;
    boolean hasReturn = false;
    int forLoopLevel = 0;

private String objToString(Obj o) {
  StringBuilder output = new StringBuilder();
  switch (o.getKind()) {
  case Obj.Con:  output.append("Con "); break;
  case Obj.Var:  output.append("Var "); break;
  case Obj.Type: output.append("Type "); break;
  case Obj.Meth: output.append("Meth "); break;
  case Obj.Fld:  output.append("Fld "); break;
  case Obj.Prog: output.append("Prog "); break;
  }

  output.append(o.getName());
  output.append(": ");

  switch (o.getType().getKind()) {
  case Struct.None:
	output.append("notype");
	break;
  case Struct.Int:
  	output.append("int");
	break;
  case Struct.Char:
	output.append("char");
	break;
  case Struct.Array:
	output.append("Arr of ");

	switch (o.getType().getElemType().getKind()) {
	case Struct.None:
	output.append("notype");
	break;
	case Struct.Int:
	output.append("int");
	break;
	case Struct.Char:
	output.append("char");
	break;
	case Struct.Class:
	output.append("Class");
	break;
	}

	break;
	case Struct.Class:
	  output.append("Class");
	  break;
	}

  output.append(", ");
  output.append(o.getAdr());
  output.append(", ");
  output.append(o.getLevel() + " ");

  return output.toString();
}

private int getClassSize(Obj class1) {
  Obj sClass = getClassField(class1, "$super");
  int size = sClass != Tab.noObj ? 0 : 1;
  size += class1.getType().getElemType().getNumberOfFields() - 2;

  if(sClass != Tab.noObj) {
    size += getClassSize(sClass);
  }

  return size;
}

private void loadList(Vector<Obj> objs) {
 for(int i = 0; i < objs.size(); i++) {
   Code.load(objs.elementAt(i));
 }
}

private void store(Vector<Obj> objs) {
 for(int i = 0; i < objs.size(); i++) {
   Code.load(objs.elementAt(i));
 }
}

private int calculateOffset(Obj class1) {
  return getClassSize(class1) - 1;
}

private void generateCallCode(Obj method) {
  Obj obj = objHelpers.pop();

  if(checkStatic(method)) {
    if(method.getName().equals("ord") || method.getName().equals("chr")) {
      return;
    }
    if(method.getName().equals("len")) {
      Code.put(Code.arraylength);
      return;
    }

    endPC.pop();
    startPC.pop();
    int dest = method.getAdr() - Code.pc;
    Code.put(Code.call);
    Code.put2(dest);
  } else {
    Obj vtSym = getClassField(obj, "$vtable");
    int ePC = endPC.pop();
    int sPC = startPC.pop();

    while(sPC != ePC) {
      Code.put(Code.buf[sPC++]);
    }

    Code.load(vtSym);
    String name = method.getName();
    Code.put(Code.invokevirtual);

    for(int i = 0; i < name.length(); i++) {
      Code.put4(name.charAt(i));
    }

    Code.put4(-1);
  }
}

private Obj getClassField(Obj obj, String name) {
  Obj class1 = obj;

  if(class1.getKind() == Obj.Elem && class1.getType().getKind() == Struct.Class) {
    class1 = new Obj(class1.getKind(), "", new Struct(Struct.Class, class1.getType()));
    class1.getType().setElementType(obj.getType());
  }
  Obj o = class1.getType().getKind() == Struct.Class ?
          (class1.getKind() == Obj.Type ?
           class1.getType().getMembersTable().searchKey(name) :
           class1.getType().getElemType().getMembersTable().searchKey(name)) :
          Tab.noObj;

  if(class1.getType().getElemType() == classT && (o == null || o == Tab.noObj))
    o = Tab.find(name);

  if(o == null)
    o = Tab.noObj;

  return o;
}

private boolean compatability(Obj class1, Struct type) {
   if(class1 == null || type == null) {
     return false;
   }

   Obj obj = class1;

   if(class1.getKind() == Obj.Elem && class1.getType().getKind() == Struct.Class) {
     class1 = new Obj(Obj.Var, "", new Struct(Struct.Class, class1.getType()));
     class1.getType().setElementType(obj.getType());
   }

   Obj sClass = new Obj(Obj.Var, "", new Struct(Struct.Class));
   sClass.getType().setElementType(type);
   sClass = getClassField(sClass, "$super");

   boolean result = false;

   if(class1.getType().compatibleWith(type)) {
     return true;
   }

   if(class1.getType().getKind() == Struct.Class && class1.getKind() != Obj.Type) {
      result |= class1.getType().getElemType().compatibleWith(type);
      result |= sClass != Tab.noObj && compatability(class1, sClass.getType().getElemType());
   }

   return result;
}

private void incrementArgs() {
  int x = rArgCounters.pop();
  x++;
  rArgCounters.push(x);
}

private int getRelOperator(String s) {
  switch(s) {
    case "<=": return Code.le;
    case ">=": return Code.ge;
    case ">" : return Code.gt;
    case "<" : return Code.lt;
    case "==": return Code.eq;
    case "!=": return Code.ne;
    case "none": return Code.eq;
  }

  return -1;
}

private void allocateComplexObject(Obj class1) {
  Obj superClass = getClassField(class1, "$super");
  int numOfFields = class1.getType().getElemType() == null ?
                    class1.getType().getNumberOfFields() :
                    class1.getType().getElemType().getNumberOfFields();
  if(superClass != Tab.noObj) {
    numOfFields += getClassSize(superClass);
  }

  Code.put(Code.new_);
  Code.put2(numOfFields*4);
}

private int getOperand(String s) {
  switch(s) {
    case "+": return Code.add;
    case "-": return Code.sub;
    case "*": return Code.mul;
    case "/": return Code.div;
    case "%": return Code.rem;
    case "++": return Code.add;
    case "--": return Code.sub;
  }

  return -1;
}

private boolean opType(String s) {
  switch(s) {
    case "+": case "-": case "/": case "*": case "%":
      return false;
    case "*=": case "/=": case "%=": case "+=": case "-=":
      return true;
  }

  return false;
}
private boolean checkStatic(Obj o) {
  if(o != null && o.getKind() == Obj.Meth) {
    if(methodObj != o)
      return o.getLocalSymbols().stream().filter(x-> x.getName() == "this").count() == 0;
    else
       return Tab.currentScope().findSymbol("this") == null;
  }

  return false;
}

//private List<Obj> getFieldsWithType(Obj obj, int kind) {
//}

//TODO: finish this
private boolean validInheritance(Obj method) {
  if(!insideClass)
    return true;

  Obj extendedMethod = searchClass(extendsType, method.getName());

  if(extendedMethod.getType() == Tab.noType) {
    return true;
  } else {
    return false;
  }
}

void printSymbols() {
   Tab.currentScope().values().stream().forEach(x-> print(x.getName()));
}

void printClassFlds(Obj obj) {
   print("***********************KRECEM**********************");
   obj.getType().getElemType().getMembersTable().symbols().stream().forEach(x -> print(x.getName()));
}
private void initVTable(Obj obj) {


}
private Obj findObj(Obj o, String name) {
  Obj obj = o;

  if(o.getKind() == Obj.Elem) {
     obj = new Obj(o.getKind(), "", new Struct(Struct.Class));
     obj.getType().setElementType(o.getType());
  }

  Obj result = Tab.noObj;
  if(obj != null && obj.getType().getKind() == Struct.Class) {
     if(insideClass &&
       obj.getType().getElemType() == classT) { //if var.ident and we are inside class of type var
       result = Tab.currentScope().getOuter().findSymbol(name);
       if(result == null)
       result = result == null ? Tab.noObj : result;
     } else if (obj.getKind() == Obj.Type) { //if Class.Method
       if(insideClass && obj  == classObj) {
         result = Tab.find(name);
       } else {
         result = obj.getType().getMembersTable().searchKey(name);
       }

       result = checkStatic(result) ? result : Tab.noObj;
     } else {
       SymbolDataStructure table = obj.getType().getElemType().getMembersTable();
       result = table.searchKey(name);
       result = result == null ? Tab.noObj : result;
     }

     if(result == Tab.noObj) { //if we didn't find key, we are looking at SUPER class recursivly
       Obj sClass = getClassField(obj, "$super");
       if(sClass != Tab.noObj)
         result = findObj(sClass, name);
     }
  }

  return result;
}

private Struct getArgument(int fpos) {
  //if we are invoking Recursion local symbols are in current Scope not in scope of method
  if(methodCalls.peek() == methodObj) {
    return Tab.currentScope().values().stream().filter(o -> o.getFpPos() == fpos).collect(Collectors.toList()).get(0).getType();
  } else {
    return methodCalls.peek().getLocalSymbols().stream().filter(o -> o.getFpPos() == fpos).collect(Collectors.toList()).get(0).getType();
  }
}

private Obj searchClass(Struct cl, String name) {
  Obj result = cl.getMembersTable().searchKey(name);
  return result == null ? Tab.noObj : result;
}

private Obj insertSymbol(int kind, String name, Struct type) {
  int numSym = Tab.currentScope().values().size();

  if(kind != Obj.Type && type.getKind() == Struct.Class) {
    Struct tmp = new Struct(Struct.Class);
    tmp.setElementType(type);
    type = tmp;
  }

  Obj result = Tab.insert(kind, name, type);

  int numSymAfter = Tab.currentScope().values().size();


  if(numSym != numSymAfter) {
    //print("Definisan simbol: " + name);
    result.getType().getElemType();
  }
  else {
    parser.report_error("Redefinisan simbol: " + name + " u tabeli simbola", null);
  }

  return result;
}

private void print(String s) { parser.report_info(s);  }

public void printResult() {
            print("=====================SINTAKSNA ANALIZA=========================");
            print("Pronadjeno: " + globalVar + " globalnih promenljivih");
            print("Pronadjeno: " + globalConst + " globalnih konstanti");
            print("Pronadjeno: " + globalArrays + " globalnih nizova");
            print("Pronadjeno: " + localVar + " lokalnih promenljivih");
            print("Pronadjeno: " + globalFunc + " globalnih funkcija");
            print("Pronadjeno: " + classDef + " definicija klasa");
            print("Pronadjeno: " + classMethodDef + " metoda");
            print("Pronadjeno: " + statementBlock + " statement blokova");
            print("Pronadjeno: " + mainFuncCalls + " poziva funkcija u mainu");
            print("Pronadjeno: " + formParsCnt + " formalnih argumenata");
            print("Pronadjeno: " + classFields + " polja klasa");
}

:}


parser code {:
    Struct boolType;
    static Logger logger;
    Obj boolObj;
    boolean _main = true;
    int depth = 0;
    boolean errorDetected = false;
    public int error_sync_size() { return 1; }
    public static void main(String args[]) throws Exception {
        java.io.FileReader r = new java.io.FileReader(args[0]);
		boolean writeToFile = false;

		if (args.length >= 3) {
			if(args[1].equals("-f")) {
				writeToFile = true;
			}

		}

		logger = new Logger(writeToFile, "parser");
        Lexer skener = new Lexer(r);

        parser p = new parser(skener);
        Symbol s = p.parse();  //pocetak parsiranja

        if(!p.errorDetected) {
          File objFile = new File(args[1]);
          if(objFile.exists())
            objFile.delete();
          Code.write(new FileOutputStream(objFile));
          System.out.println("************************USPESNO ZAVRSENO PARSIRANJE!*************************");
        }
    }

    /***********************************************************************
    * slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    ***********************************************************************/
    public void report_fatal_error(String message, Object   info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("Sintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_info(String message) {
      logger.log(message);
    }

    public void report_error(String message, Object info)
    {
      errorDetected = true;

      if (info != null && info instanceof Symbol) {
          Symbol symbol = (Symbol)info;
          message += " " + symbol.left + ":" + symbol.right + " " + message;
      }

      logger.error(message);
    }

    public void report_error(String message, int row, int column) {
      report_error("" + row + ":" + column + " " + message, null);
    }
:}



terminal IDENT, NUMCONST,BOOLCONST, CHARCONST;

terminal MULOPLEFT, MULOPRIGHT, MINUS, PLUS, ADDOPRIGHT;
terminal RELOP, ASSIGN, SCOLIN, DOT;
terminal DPLUS, DMINUS, AND, OR, COLIN;
terminal LBR, RBR, LSBR, RSBR, LCBR, RCBR;

terminal CONST, CLASS, EXTENDS, STATIC, VOID, IF, ELSE, FOR, BREAK;
terminal CONTINUE, RETURN, PRINT, READ, PROGRAM, NEW;

non terminal Program, ProgName, Declarations, DeclRepeat, ConstDecl, ConstDef, ConstDefRepeat;
non terminal VarDeclGlobal, VarOpt, VarOptGlobalRepeat,VarDeclLocalWithError, VarDeclClassRepeatOpt;
non terminal VarDeclLocal, VarDeclClassRepeat, VarOptLocalRepeat, VarDeclLocalRepeat;
non terminal MethodImplOpt, MethodDecl, MethodDeclRepeat, FormParsWithError, Parameter, ParameterColinError, ParameterRbrError, ParameterRepeat;
non terminal Statement, StatementRepeat, ElsStmt, DesignatorStatement, DesignatorStatementErr;
non terminal DesignatorStmtOptions, DesignatorStatementOpt, ActPars, ActParsHelper, ActualParameter, ActParamRepeat;
non terminal CondTerm, CondTermOr, CondFact, CondFactAnd;
non terminal RelopExp, OptParameters;
non terminal DesignatorParam, DesignatorParamRep;
non terminal Assignop, AddopLeft, Condition, VarDeclLocalScolinError, VarDeclLocalLcbrError, VarDeclLocalRepeatOpt;
non terminal StartVarOpt, EndVarOpt, ActParsWithError, Addop, Mulop, RightOperands;

non terminal java.lang.Integer ConstOpt;
non terminal Struct NewParameters, Type, ExtType, ClassType, ClassDecl, Extends;
non terminal Boolean ConditionOpt, ConditionWithError, SbrOpt, StaticOpt, MinusOpt;
non terminal Obj ClassVar, ExprOrError, Designator, Constant, Term, Expr, ExprComb, RightExpr, Factor;
non terminal Obj AssignWithError, ExprOpt;
non terminal Integer CondFactRepeat, CondTermRep;

precedence left ELSE;
//Think about chaining local symbols to program!
Program ::= PROGRAM
            {:
              print("=====================SEMANTICKA ANALIZA=========================");
              Tab.openScope();
              helperObj = insertSymbol(Obj.Var, "$helper", Tab.intType);
              dataSize = 1;
              VirtualTable.setParser(parser);
              VTStorage.setParser(parser);
              global = true;
            :}
            ProgName DeclRepeat LCBR
            {:
              global = false;
            :}
            MethodDeclRepeat RCBR
            {:
              printResult();
              Tab.dump();
              Code.dataSize = dataSize;
              Tab.closeScope();
            :};
ProgName ::= IDENT:progName
             {:
                insertSymbol(Obj.Prog, progName.toString(), Tab.noType);
             :};

Declarations ::= ConstDecl | VarDeclGlobal | ClassDecl;
DeclRepeat ::= /* epsilon */
              |
               Declarations DeclRepeat;

Constant ::= NUMCONST:match
             {:
               RESULT = new Obj(Obj.Con, "", Tab.intType);
               RESULT.setAdr(Integer.parseInt(match.toString()));
             :}
           | BOOLCONST:match
             {:
               RESULT = new Obj(Obj.Con, "", parser.boolType);
               RESULT.setAdr(match.toString().equals("true") ? 1 : 0);
             :}
           |
             CHARCONST:match
             {:
               RESULT = new Obj(Obj.Con, "", Tab.charType);
               RESULT.setAdr(match.toString().charAt(1));
             :};
ConstDecl ::= CONST Type:type {: varTypeHelper = type; :}
              ConstDefRepeat SCOLIN {:  :};
ConstDef  ::=  IDENT:varName
               {:
                 conHelper = insertSymbol(Obj.Con, varName.toString(), varTypeHelper);
               :}
               ASSIGN Constant:cn
               {:
                  if(cn.getType().getKind() != varTypeHelper.getKind()) {
                     parser.report_error("Tip konstante i konstanta se ne poklapaju!", varNameleft, varNameright);
                  }

                  conHelper.setAdr(cn.getAdr());
               :};
ConstDefRepeat ::= ConstDef {: if(global) globalConst++; :}
                  |
                   ConstDef COLIN ConstDefRepeat {: if(global) globalConst++; :} ;

//Proveri sta radis ovde mozda ne moze ovako
VarDeclGlobal ::= Type:varType {: varTypeHelper = varType; :}
                  VarOptGlobalRepeat
                  {: if(global && !insideClass && !insideMain) {
                    if(isArray)
                      globalArrays++;
                    else
                      globalVar++;
                    } else if(insideClass && !insideMethod) {
                      classFields++;
                    }
                  :};
VarOpt  ::= IDENT:varName SbrOpt:array
            {:
               Obj o = insertSymbol(insideClass && !insideMethod ? Obj.Fld : Obj.Var, varName.toString(), array ? new Struct(Struct.Array, varTypeHelper) : varTypeHelper);

               if(insideClass) {
                 o.setAdr(o.getAdr() + offset);
               } else if(global) {
                 o.setAdr(dataSize++);
               }
            :};

StartVarOpt ::= VarOpt COLIN  |
                error:e COLIN {: parser.report_error("Uspesan oporavak od greske do \",\"", eleft, eright); :};
EndVarOpt ::= VarOpt SCOLIN |
              error:e SCOLIN {: parser.report_error("Uspesan oporavak od greske do \";\"", eleft, eright); :};

VarOptGlobalRepeat ::= StartVarOpt VarOptGlobalRepeat {: if(!insideClass && !insideMain) {
                                                           if(isArray)
                                                             globalArrays++;
                                                           else
                                                                       globalVar++;
                                                                  } else if(insideClass && !insideMethod) {
                                                                       classFields++;
                                                                  }
                                                      :}
                      | EndVarOpt;

VarDeclLocal ::= Type:varType {: varTypeHelper = varType; :}
                 VarOptLocalRepeat;

VarOptLocalRepeat ::= VarOpt
                     {: if(insideMain) {
                          localVar++;
                        } else if(insideClass && !insideMethod) {
                          classFields++;
                        }
                     :}
                      COLIN  VarOptLocalRepeat
                    |
                      VarOpt
                     {: if(insideMain) {
                          localVar++;
                        } else if(insideClass && !insideMethod) {
                          classFields++;
                        }
                     :};
VarDeclLocalScolinError ::= VarDeclLocal SCOLIN
                          |
                            error:e SCOLIN {: parser.report_error("Uspesan oporavak od greske do \";\"", eleft); :};
VarDeclLocalLcbrError ::= VarDeclLocal SCOLIN LCBR
                        |
                          error:e LCBR {: parser.report_error("Uspesan oporavak od greske do \"{\"", eleft, eright); :};
VarDeclLocalRepeat ::= VarDeclLocalScolinError VarDeclLocalRepeat
                     |
                       VarDeclLocalLcbrError;
//TODO: Error can have wrong terminal for example "}"
VarDeclLocalWithError ::= VarDeclLocal
                        | error:e {: parser.report_error("Uspesan oporavak od greske kod deklarisanje polja klase", eleft, eright); :};
VarDeclClassRepeat ::= VarDeclLocalWithError SCOLIN
                     | VarDeclLocalWithError SCOLIN VarDeclClassRepeat;
VarDeclClassRepeatOpt ::= |
                          VarDeclClassRepeat;
VarDeclLocalRepeatOpt ::= LCBR
                        | VarDeclLocalRepeat;
SbrOpt  ::=  {: RESULT = isArray = false; :}
          |  LSBR RSBR {: RESULT = isArray = true; :};
//TODO: VarDeclLocal should go up to LCBR but not sure LCBR will be there!
ClassDecl ::= ClassType:cT ClassVar Extends
              {:
                VirtualTable vt = VTStorage.insertVTClass(classObj.getType().toString());
                vt.setAddr(dataSize);
                insertSymbol(Obj.Fld, "$vtable", Tab.intType);

                if(extendsType != Tab.noType) {
                  Obj o = insertSymbol(Obj.Fld, "$super", extendsType);
                  offset = calculateOffset(o);
                } else {
                  offset = 0;
                }
              :}
              LCBR VarDeclClassRepeatOpt MethodImplOpt RCBR
              {:
                Tab.chainLocalSymbols(cT);
                Tab.closeScope();
                VirtualTable vt = VTStorage.fill(classObj);
                vts.push(vt);
                addresses.push(dataSize);
                dataSize+=vt.getSize();

                insideClass = false;
              :};
ClassType ::= CLASS:classType
              {:
                 RESULT = new Struct(Struct.Class);
                 classT = RESULT;
                 insideClass = true;
                 classDef++;
              :};
ClassVar ::= IDENT:className
             {:
                RESULT = insertSymbol(Obj.Type, className.toString(), classT);
                classObj = RESULT;
                Tab.openScope();
             :};
Extends ::= /* epsilon */ {: extendsType = Tab.noType; :}
          |
            EXTENDS:ex Type:type
            {:
              if(type.getKind() != Struct.Class) {
                parser.report_error("Klasa mora nasledjivati drugu klasu!", exleft, exright);
                extendsType = Tab.noType;
              } else {
                 if(type == classT) {
                   parser.report_error("Klasa ne moze nasledjivati samu sebe!", exleft, exright);
                   extendsType = Tab.noType;
                 } else {
                   extendsType = type;
                 }
              }
            :}
           |
            error:e
            {:
              extendsType = Tab.noType;
              parser.report_error("Uspesan oporavak od greske kod nasledjivanja klase", eleft, eright);
            :};
MethodImplOpt ::= |
                  LCBR MethodDeclRepeat RCBR;
StaticOpt ::= /* epsilon */ {: RESULT = false; :}
             |
              STATIC:s
              {:
                 if(!insideClass) {
                   parser.report_error("Kljucna rec static se moze koristiti samo uokviru klase!", sleft, sright);
                 }

                 RESULT = true;
              :};
MethodDecl ::=  StaticOpt:isStatic ExtType:retType IDENT:name
                {:
                   if(isStatic && !insideClass) {
                     parser.report_error("Globalne metode ne mogu biti staticke!", nameleft, nameright);
                   }

                   if(name.toString().equals("main")) {
                     insideMain = true;
                     Code.mainPc = Code.pc;
                   }

                   if(insideClass && !isStatic)
                     classMethodDef++;
                   else {
                     globalFunc++;
                   }

                   insideMethod = true;
                   methodObj = insertSymbol(Obj.Meth, name.toString(), retType);
                   methodObj.setAdr(Code.pc);
                   argCount = 0;
                   Tab.openScope();

                   if(!isStatic && insideClass) {
                     Obj obj = insertSymbol(Obj.Var, "this", classT);
                     obj.setFpPos(argCount);
                     argCount++;
                   }
                :}
                FormParsWithError VarDeclLocalRepeatOpt
                {:
                  methodObj.setLevel(argCount);
                  Code.put(Code.enter);
                  Code.put(argCount);
                  Code.put(Tab.currentScope.getnVars());
                  if(name.toString().equals("main")) {
                     while(!vts.empty()) {
                        VirtualTable vt = vts.pop();
                        int addr = addresses.pop();

                        vt.writeToData(addr);
                     }
                  }

                :}
                StatementRepeat RCBR:r
                {:
                   if(insideMain) {
                     insideMain = false;
                   }
                   if(retType != Tab.noType && !hasReturn) {
                      parser.report_error("Nedostaje return statement u metodi!", rleft, rright);
                   }

                   Code.put(Code.exit);
                   Code.put(Code.return_);
                   hasReturn = false;
                   insideMethod = false;
                   Tab.chainLocalSymbols(methodObj);
                   Tab.closeScope();
                :};

MethodDeclRepeat ::= /* epsilon */
                   |
                     MethodDecl MethodDeclRepeat;
FormParsWithError ::= LBR  RBR
                    |
                      LBR ParameterRepeat;
Parameter ::= Type:type IDENT:varName SbrOpt:array
              {:
                Obj obj = insertSymbol(Obj.Var, varName.toString(), array ? new Struct(Struct.Array, type) : type);
                obj.setFpPos(argCount);
                argCount++;
                formParsCnt++;
              :};
ParameterColinError ::= Parameter COLIN
                      |
                        error:e COLIN {: parser.report_error("Uspesan oporavak od greske do \",\"", eleft, eright); :};
ParameterRbrError ::= Parameter RBR
                    |
                      error:e RBR {: parser.report_error("Uspesan oporavak od greske do \")\"", eleft, eright); :};
ParameterRepeat ::= ParameterRbrError
                    | ParameterColinError ParameterRepeat;

Type ::= IDENT:typeName
{:
    Obj typeNode = Tab.find(typeName.toString());
   	if (typeNode == Tab.noObj) {
   		parser.report_error("Nije pronadjen tip " + typeName + " u tabeli simbola", typeNameleft, typeNameright);
   		RESULT = Tab.noType;
   	}
   	else {
   		if (Obj.Type == typeNode.getKind()) {
   			RESULT = typeNode.getType();
   		}
   		else {
   			parser.report_error("Ime ne predstavlja tip ", typeNameleft, typeNameright);
   			RESULT = Tab.noType;
   		}
   	}
:};

ExtType ::= Type:type {: RESULT = type; :}
           |
            VOID {: RESULT = Tab.noType; :};

Statement ::= DesignatorStatement SCOLIN
            |
              IF LBR ConditionWithError:e RBR
              {:
                if(e)
                {
                  int numOfT = numOfTerms.pop();
                  for(int i = 0; i < numOfT; i++) {
                    int addr = trueJumpAddr.pop();
                    Code.fixup(addr);
                  }
                }
              :}
              Statement
              {:
                if(e) {
                  Code.putJump(0);
                  int addr1 = Code.pc - 2;
                  trueJumpAddr.push(addr1);
                  Code.fixup(condEndJump.pop());
                }
              :}
              ElsStmt
              {:
                if(e)
                  Code.fixup(trueJumpAddr.pop());
              :}
            |
              FOR {: forLoopLevel++; :} LBR DesignatorStatementOpt
              {:
                breakJumpNum.push(0);
                backAddr = Code.pc;
              :}
              SCOLIN ConditionOpt:e SCOLIN
              {:
                forEndJump.push(Code.pc);
              :}
               DesignatorStatementOpt RBR
              {:
                Code.putJump(backAddr);

                int numOfT = numOfTerms.pop();
                for(int i = 0; i < numOfT; i++) {
                  int addr = trueJumpAddr.pop();
                  Code.fixup(addr);
                }
              :}
              Statement
              {:
                Code.putJump(forEndJump.pop());
                if(e)
                  Code.fixup(condEndJump.pop());
                forLoopLevel--;

                int n = breakJumpNum.pop();

                for(int i = 0; i < n; i++) {
                  Code.fixup(breakJumpAddr.pop());
                }
              :} //not sure if SCOLIN needed here
            |
              BREAK:b SCOLIN
              {:
                if(forLoopLevel == 0) {
                  parser.report_error("break se sme koristiti samo uokviru petlje!", bleft, bright);
                } else {
                  Code.putJump(0);
                  breakJumpAddr.push(Code.pc-2);
                  int x = breakJumpNum.pop();
                  breakJumpNum.push(x+1);
                }
              :}
            |
              CONTINUE:c SCOLIN
              {:
                if(forLoopLevel == 0) {
                  parser.report_error("continue se sme koristiti samo uokviru petlje!", cleft, cright);
                } else {
                  Code.putJump(forEndJump.peek());
                }
              :}
            |
              RETURN:r ExprOpt:e SCOLIN
              {:
                hasReturn = true;

                Code.put(Code.exit);
                Code.put(Code.return_);

                if(!insideMethod) {
                  parser.report_error("Naredba return se sme koristiti samo uokviru funckije/metode", rleft, rright);
                } else {
                  if(methodObj.getType() != e.getType()) {
                    parser.report_error("Povratni tip metode i naredbe return se ne poklapaju", rleft, rright);
                  }
                }

              :}
            |
              READ:r LBR Designator:des RBR SCOLIN
              {:
                 startPC.pop();
                 if(des.getKind() != Obj.Var &&
                    des.getKind() != Obj.Fld &&
                    des.getKind() != Obj.Elem) {
                   parser.report_error("Ne moze se pozvati READ za ovaj simbola!", rleft, rright);
                 }

                 if(des.getType() != Tab.intType &&
                    des.getType() != Tab.charType &&
                    des.getType().getKind() != Struct.Bool) {
                   parser.report_error("Ne moze se pozvati READ za ovaj tip simbola!", rleft, rright);
                 }

                if(des.getType() == Tab.intType) {
                  Code.put(Code.read);
                } else {
                  Code.put(Code.bread);
                }

                Code.store(des);
                if(insideMain) mainFuncCalls++;
              :}
            |
              PRINT:p LBR ExprComb:e ConstOpt:c RBR SCOLIN
              {:
                if(e.getType() != Tab.intType &&
                   e.getType() != Tab.charType &&
                   e.getType().getKind() != Struct.Bool) {
                   parser.report_error("Ne moze se pozvati PRINT za ovaj tip simbola!", pleft, pright);
                 }

                if(insideMain) mainFuncCalls++;

                if(e.getType() == Tab.intType) {
                  Code.loadConst(c == null ? 5 : c);
                  Code.put(Code.print);
                } else if (e.getType() == Tab.charType) {
                  Code.loadConst(c == null ? 1 : c);
                  Code.put(Code.bprint);
                }
              :}
            |
              LCBR StatementRepeat RCBR {: statementBlock++; :};
StatementRepeat ::= |
                    Statement StatementRepeat;
ElsStmt ::= |
            ELSE Statement;
ConstOpt ::= /* epsilon */ {: RESULT = null; :}
           |
             COLIN NUMCONST:n {: RESULT = java.lang.Integer.parseInt(n.toString()); :};


DesignatorStatement ::= Designator:des
                        {:
                          startPC.pop();
                          desHelper = des;
                        :}
                        AssignWithError:res
                        {:
                          if(des.getKind() != Obj.Var &&
                             des.getKind() != Obj.Fld &&
                             des.getKind() != Obj.Elem) {
                               parser.report_error("" + desleft + ":" + desright + " Ne moze se dodeliti vrednost ovom simbolu!", null);
                          }

                          if(des != Tab.noObj &&
                             !compatability(des, res.getType())) {
                            parser.report_error("" + desleft + ":" + desright + " Izraz je pogresnog tipa!", null);
                          }

                          Code.store(des);
                        :}
                      |
                        Designator:des
                        {:
                          endPC.push(Code.pc);
                          if(des.getKind() != Obj.Meth) {
                            parser.report_error("" + desleft + ":" + desright + " Simbol " + des.getName() + " nije metoda!", null);
                            methodObjHelper = new Obj(Obj.Meth, "error", Tab.noType);
                          } else {
                            methodObjHelper = des;
                          }

                          rArgCount = checkStatic(methodObjHelper) ? 0 : 1;
                          rArgCounters.push(rArgCount);
                          objHelpers.push(objHelper);
                          methodCalls.push(methodObjHelper);
                        :}
                        LBR ActParsWithError RBR
                        {:
                          if(des.getKind() == Obj.Meth) {
                            generateCallCode(des);
                          }

                          if(insideMain)
                            mainFuncCalls++;
                          rArgCounters.pop();
                          objHelper = null;
                        :}
                      |
                        Designator:des DesignatorStmtOptions:op
                        {:
                          startPC.pop();
                          if(des.getKind() != Obj.Var &&
                             des.getKind() != Obj.Fld &&
                             des.getKind() != Obj.Elem) {
                            parser.report_error("" + desleft + ":" + desright + "Ne moze se izvesti operacija nad simbolom " + des.getName() + "!", null);
                          }

                          if(des.getType() != Tab.intType) {
                            parser.report_error("" + desleft + ":" + desright + " Operacija se moze izvesti samo na tipu: int!", null);
                          }
                          if(isComplexObj) {
                            if(des.getKind() == Obj.Elem)
                              Code.put(Code.dup2);
                            else
                              Code.put(Code.dup);
                          }
                          isComplexObj = false;
                          Code.load(des);
                          Code.loadConst(1);
                          Code.put(getOperand(op.toString()));
                          Code.store(des);
                        :};
AssignWithError ::= Assignop:op
                    {:
                       int operand = getOperand("" + op.toString().charAt(0));
                       if(operand != -1) {
                         if(desHelper.getKind() == Obj.Elem) {
                           Code.put(Code.dup2);
                         } else if (desHelper.getKind() == Obj.Fld) {
                           Code.put(Code.dup);
                         }
                       }
                    :}
                    ExprOrError:expr
                    {:
                       int operand = getOperand("" + op.toString().charAt(0));
                       if(operand != -1) {
                         Code.store(helperObj);
                         Code.load(desHelper);
                         Code.load(helperObj);
                         Code.put(operand);
                       }

                       if(expr.getKind() != Obj.Type && expr.getType().getKind() == Struct.Class && !expr.getName().equals("null")) {
                         RESULT = new Obj(expr.getKind(), expr.getName(), expr.getType().getElemType());
                       } else {
                         RESULT = expr;
                       }
                    :};

//Think about this!
DesignatorStmtOptions ::=  DPLUS:d {: RESULT = d; :} | DMINUS:d {: RESULT = d; :};
DesignatorStatementOpt ::= |
                           DesignatorStatementErr;
DesignatorStatementErr ::= DesignatorStatement
                         | error:e {: parser.report_error("Uspesan oporavak od greske prilikom naredbe", e); :};
ActParsHelper ::= ExprComb:e
                  {:
                    methodObjHelper = methodCalls.peek();
                    Struct arg = methodObjHelper.getName() != "error" ? getArgument(rArgCounters.peek()) : Tab.noType;

                    if (arg.getKind() == Struct.Class && arg.getElemType() != null) {
                       arg = arg.getElemType();
                    }

                    if(methodObjHelper.getName() != "error" &&
                       methodObjHelper.getLevel() > rArgCounters.peek() &&
                       !compatability(e, arg) &&
                       !(methodObjHelper.getName().equals("len") && arg.getKind() == Struct.Array)) {
                      parser.report_error("" + eleft + ":"  + eright + " Pogresan tip " + (rArgCounters.peek()) + ". argumenta!", null);
                    }

                    incrementArgs();
                  :}
                |
                  ActParsHelper COLIN ExprComb:e
                  {:
                    methodObjHelper = methodCalls.peek();
                    Struct arg = methodObjHelper.getName() != "error" ? getArgument(rArgCounters.peek()) : Tab.noType;

                    if (arg.getKind() == Struct.Class && arg.getElemType() != null) {
                       arg = arg.getElemType();
                    }

                    if(methodObjHelper.getName() != "error" &&
                       methodObjHelper.getLevel() > rArgCounters.peek() &&
                       !compatability(e, arg)) {
                      parser.report_error("" + eleft + ":" + eright + " Pogresan tip " + (rArgCounters.peek()) + ". argumenta!", null);
                    }

                    incrementArgs();
                  :};
ActParsWithError ::= ActPars:a
                     {:
                        methodObjHelper = methodCalls.peek();

                        if(methodObjHelper.getName() != "error") {
                          if(rArgCounters.peek() != methodObjHelper.getLevel()) {

                            parser.report_error("" + aleft + ":" + aright + " Pogresan broj argumenata za metodu " + methodObjHelper.getName(), null);
                          }
                        }
                     :}
                   |
                     error:e {: parser.report_error("Uspesan oporavak od greske prilikon prosledjivanja argumenata funkciji", eleft, eright); :};
ActPars ::= /* epsilon */
          |
            ActParsHelper;
ActualParameter ::= COLIN ExprComb;
ActParamRepeat ::= /* epsilon */
                 |
                   ActualParameter ActParamRepeat;
Condition ::= CondTerm CondTermRep:r
              {:
                Code.putJump(0);
                condEndJump.push(Code.pc-2);
                numOfTerms.push(r+1);
              :};

ConditionOpt ::= /* epsilon */ {:  Code.putJump(0); trueJumpAddr.push(Code.pc-2); numOfTerms.push(1); RESULT = false; :}
               |
                 ConditionWithError:e {: RESULT = e; :};
ConditionWithError ::= Condition {: RESULT = true; :}
                     |
                       error:e {: numOfTerms.push(0); RESULT = false; parser.report_error("Uspesan oporavak od greske prilikom uslova", eleft, eright); :};
CondTerm ::= CondFact CondFactRepeat:r
             {:
               Code.putJump(0);
               trueJumpAddr.push(Code.pc-2);
               int numOfF = r + 1;

               for(int i = 0; i < numOfF; i++) {
                 int addr = falseJumpAddr.pop();
                 Code.fixup(addr);
               }
             :};
CondTermOr ::= OR CondTerm;
CondTermRep ::= /* epsilon */ {: RESULT = 0; :}
              |
                CondTermOr CondTermRep:r {: RESULT = r + 1; :};

CondFact ::= ExprComb:e RelopExp:r
             {:
                 int op = getRelOperator(r.toString());

                 if("none".equals(r.toString())) {
                   if(e.getType().getKind() != Struct.Bool) {
                     parser.report_error("" + eleft + ":" + eright + " Operand mora biti tipa bool u uslovnom iskazu!", null);
                   }
                   Code.loadConst(1);
                }

                 if(e.getType().getKind() == Struct.Class && op != Code.eq && op != Code.ne) {
                     parser.report_error("" + eleft + ":" + eright + " Ne moze se koristiti ovaj operand sa klasama!", null);
                 }

                 Code.putFalseJump(op, 0);
                 int adr = Code.pc - 2;
                 falseJumpAddr.push(adr);
             :};
CondFactAnd ::= AND CondFact;
CondFactRepeat ::= /* epsilon */ {: RESULT = 0; :}
                 |
                   CondFactAnd CondFactRepeat:r {: RESULT = r+1; :};
RelopExp ::= /* epsilon */ {: RESULT = "none"; :}
           |
             RELOP:r ExprComb {: RESULT = r; :};

MinusOpt ::= /* epsilon */ {: RESULT = false; :}
           |
             MINUS {: RESULT = true; :};


RightExpr ::= Expr:des
              {:
                int decrement = 0;
                int pcHack = Code.pc;

                if(hasOperand) {
                  opCode = Code.buf[Code.pc - 1];
                  decrement++;
                }

                //hacky way to determin how big is LOAD command
                Code.load(des);
                pcHack = Code.pc - pcHack;
                decrement += 2*pcHack;
                Code.pc -= decrement;

                if(des.getKind() == Obj.Elem) {
                  Code.put(Code.dup2);
                  Code.put(Code.dup2);
                }
                else if(des.getKind() == Obj.Fld) {
                  Code.put(Code.dup);
                  Code.put(Code.dup);
                }
             :}
              RightOperands:op ExprOrError
             {:
               int operand = getOperand("" + op.toString().charAt(0));

               if(des.getKind() != Obj.Var &&
                  des.getKind() != Obj.Fld &&
                  des.getKind() != Obj.Elem) {
                 parser.report_error("" + desleft + ":" + desright + " Ovaj simbol ne moze ici sa ovim operandom!", null);
               } else {
                 Code.store(helperObj);
                 Code.load(des);
                 Code.load(helperObj);
                 Code.put(operand);
                 Code.store(des);
                 Code.load(des);

                 if(opCode != -1) {
                   Code.put(opCode);
                 }

                 opCode = -1;
               }

               RESULT = des;
             :};


Expr ::= MinusOpt:m Term:t
         {:
           if(m) {
             Code.put(Code.neg);
           }

           RESULT = t;
         :}
       |
         Expr:e Addop:op Term:t
         {:
          if(e.getType() != Tab.intType || t.getType() != Tab.intType) {
            parser.report_error("" + tleft + ":" + tright + " Sabirci moraju biti tipa int!", null);
          }

          if(!e.getType().compatibleWith(t.getType())) {
            parser.report_error("" + eleft + ":" + eright + " Nekompatibilni tipovi!", null);
          }

          hasOperand = true;
          int operand = getOperand("" + op.toString().charAt(0));
          Code.put(operand);

          RESULT = t;
        :};


ExprComb ::= Expr:e
            {:
              RESULT = e;
            :}
           |
             RightExpr:e
             {:
               RESULT = e;
             :};

ExprOpt ::= /* epsilon */ {: RESULT = Tab.noObj; :}
          |
            ExprComb:e {: RESULT = e; :};
ExprOrError ::= ExprComb:e {: RESULT = e; :}
              |
                error:e {: RESULT = Tab.noObj; parser.report_error("Uspesan oporavak od greske prilikom izraza", eleft, eright); :};

Term ::= Factor:factor
         {:
           RESULT = factor;
           hasOperand = false;
         :}
       |
         Term:t MULOPLEFT:op Factor:f
         {:
           if(t.getType() != Tab.intType || f.getType() != Tab.intType) {
             parser.report_error("Cinilac mora biti tipa int!", op);
           }

           hasOperand = true;
           int operand = getOperand("" + op.toString().charAt(0));
           Code.put(operand);

           RESULT = f;
         :};

Factor ::= Designator:des
           {:
             endPC.push(Code.pc);
             methodCalls.push(des);
             objHelpers.push(objHelper);
             int argCnt = (checkStatic(methodCalls.peek()) ? 0 : 1);
             rArgCounters.push(argCnt);
             RESULT = des;
           :}
           OptParameters
           {:
             rArgCounters.pop();

             if(des.getKind() == Obj.Meth) {
               generateCallCode(des);
             } else {
               endPC.pop();
               startPC.pop();
               objHelpers.pop();
               Code.load(des);
             }

             methodCalls.pop();
           :}
         |
           Constant:c
           {:
             Code.load(c);
             RESULT = c;
           :}
         |
           NEW:n Type:type NewParameters:nparam
           {:
             //TODO noidea!
             if(nparam != Tab.intType && nparam != Tab.noType) {
               parser.report_error("Parametri operanda new moraju biti tipa int!", nleft, nright);
             }

             RESULT = new Obj(Obj.Type, "", type);;

             if(nparam == Tab.noType && type.getKind() != Struct.Class) {
               parser.report_error("" + nleft + ":" + nright + " Simbol nije klasnog tipa", nleft, nright);
             }
             if(nparam != Tab.noType) {
               Code.put(Code.newarray);
               if(type == Tab.charType) {
                 Code.put(0);
               } else {
                 Code.put(1);
               }

               RESULT = new Obj(Obj.Var, "", new Struct(Struct.Array, type));
             } else if(type.getKind() == Struct.Class) {
               RESULT = new Obj(Obj.Type, "", type);;
               allocateComplexObject(RESULT);

               //store value to VTable
               Code.put(Code.dup);
               VirtualTable vt = VTStorage.get(type);
               if(vt != null) {
                 Code.loadConst(vt.getAddr());
                 Code.store(type.getMembersTable().searchKey("$vtable"));
               }
             }
           :}
         |
           LBR ExprComb:e RBR {: RESULT = e; :};

OptParameters ::= /* epsilon */
                |
                  LBR ActParsWithError RBR  {: if(insideMain) mainFuncCalls++; :};

NewParameters ::= /* epsilon */ {: RESULT = Tab.noType; :}
                |
                  LSBR ExprComb:e RSBR {: RESULT = e.getType(); :};

Designator ::= Designator:des DOT IDENT:ident
               {:
                  if(des.getType().getKind() != Struct.Class) {
                    if(des != Tab.noObj)
                      parser.report_error("" + desleft + ":" + desright + " Promenljiva" + des.getName() +  " nije klasnog tipa!", null);
                    RESULT = Tab.noObj;
                  } else {
                    RESULT = findObj(des, ident.toString());
                    if(RESULT == Tab.noObj) {
                      parser.report_error("Nepostojece polje/metoda " + ident.toString() +  " za varijablu " + des.getName(), identleft, identright);
                    } else if(des.getKind() != Obj.Type) {
                      Code.load(des);
                      isComplexObj = true;
                    }
                  }

                  if(RESULT != Tab.noObj) {
                    parser.report_info("Pretraga na (" + identleft + "), nadjeno " + objToString(RESULT));
                  }

                  if(RESULT.getKind() == Obj.Meth) {
                    thisHelper = des;
                    classCall = true;
                    objHelper = des;
                  }
               :}
             |
               Designator:des LSBR
               {:
                  if(des.getType().getKind() != Struct.Array) {
                    parser.report_error("" + desleft + ":" + desright + " Promenljiva" + des.getName() +  " nije tipa niz!", null);
                    RESULT = Tab.noObj;
                  } else {
                    Code.load(des);
                    RESULT = new Obj(Obj.Elem, "", des.getType().getElemType());
                  }

                  arrayHelper = des;
                  isComplexObj = true;
               :}
               ExprOrError RSBR
             |
               IDENT:ident
               {:
                 startPC.push(Code.pc);
                 Obj des = Tab.currentScope().findSymbol(ident.toString());
                 Obj tryClass = Tab.find("this"); //we search for this - if we are inside method and inside non static class this will be found
                 des = des == null ? findObj(tryClass, ident.toString()) : des; //we prioritiez fields of class by first trying to find it there

                 if(insideMethod && checkStatic(methodObj)) {//ifStatic
                   if(des.getKind() == Obj.Fld) {
                     des = Tab.noObj;
                   } else if(des.getKind() == Obj.Meth && !checkStatic(des))  {
                     des = Tab.noObj;
                   }
                 }

                 if(des == Tab.noObj) {
                   des = Tab.find(ident.toString());
                 }

                 if(des == Tab.noObj) {
                   parser.report_error("Ne postoji simbol " + ident.toString() + " u tabeli simbola!", identleft, identright);
                 } else {
                     if(tryClass != Tab.noObj && (des.getKind() == Obj.Fld || des.getKind() == Obj.Meth)) {
                       Code.load(tryClass);
                       isComplexObj = true;
                       classCall = true;
                     } else {
                       classCall = false;
                       isComplexObj = false;
                     }

                   parser.report_info("Pretraga na (" + identleft + "), nadjeno " + objToString(des));
                 }

                 if(des.getKind() == Obj.Meth && isComplexObj) {
                   objHelper = tryClass;
                   thisHelper = tryClass;
                 } else {
                   objHelper = Tab.noObj;
                   thisHelper = Tab.noObj;
                 }

                 RESULT = des;
               :};

Assignop ::= ASSIGN:a {: RESULT = a; :}
           |
             ADDOPRIGHT:a {: RESULT = a; :}
           |
             MULOPRIGHT:a {: RESULT = a; :};
Addop ::= AddopLeft:al {: RESULT = al.toString(); :};
AddopLeft ::= PLUS:p {: RESULT = p; :} | MINUS:m {: RESULT = m; :};
Mulop ::= MULOPLEFT:a {: RESULT = a.toString(); :};

RightOperands ::= ADDOPRIGHT:a {: RESULT = a.toString(); :} | MULOPRIGHT:b {: RESULT = b.toString(); :};
